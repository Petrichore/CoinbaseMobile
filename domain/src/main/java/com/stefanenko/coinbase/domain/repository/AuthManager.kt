@file:Suppress("PrivatePropertyName")

package com.stefanenko.coinbase.domain.repository

import android.net.Uri
import com.stefanenko.coinbase.data.network.dto.token.RequestAccessToken
import com.stefanenko.coinbase.data.network.dto.token.RequestRefreshToken
import com.stefanenko.coinbase.data.network.dto.token.RequestRevokeToken
import com.stefanenko.coinbase.data.service.OAuth2Service
import com.stefanenko.coinbase.domain.entity.ResponseState
import com.stefanenko.coinbase.domain.util.oAuthScope.ScopeBuilder
import com.stefanenko.coinbase.domain.util.UrlBuilder
import com.stefanenko.coinbase.domain.util.oAuthScope.Scope
import java.lang.IllegalArgumentException
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.Exception

@Singleton
class AuthManager @Inject constructor(
    private val oAuth2Service: OAuth2Service,
    private val scopeBuilder: ScopeBuilder,
    private val urlBuilder: UrlBuilder
) {

    private val clientId = "979fbe1bf76735a1179d82729ed941ffdd5331686891c10c12d1b25f24ac5293"
    private val clientSecret = "208dfff66f3af0ad840541b2dc41f417ce785f187913acb6837bdb39e338e207"
    private val tokenType = "Bearer "

    private val BASE_AUTH_URL = "https://www.coinbase.com/oauth/authorize"
    private val REDIRECT_URI_VALUE = "urn:ietf:wg:oauth:2.0:oob"

    private val RESPONSE_TYPE_KEY = "response_type"
    private val RESPONSE_TYPE_VALUE = "code"

    private val REDIRECT_URI_KEY = "redirect_uri"

    private val CLIENT_ID_KEY = "client_id"
    private val SCOPE_KEY = "scope"

    private val GRANT_TYPE_ACCESS_TOKEN = "authorization_code"
    private val GRANT_TYPE_REFRESH_TOKEN = "refresh_token"

    internal fun startAuth(): Uri {
        val scopeSting = scopeBuilder.build(
            Scope.Wallet.User.READ,
            Scope.Wallet.User.EMAIL,
            Scope.Wallet.Accounts.READ,
            Scope.Wallet.Accounts.UPDATE
        )

        val url = urlBuilder.buildUrl(
            BASE_AUTH_URL,
            Pair(CLIENT_ID_KEY, clientId),
            Pair(REDIRECT_URI_KEY, REDIRECT_URI_VALUE),
            Pair(RESPONSE_TYPE_KEY, RESPONSE_TYPE_VALUE),
            Pair(SCOPE_KEY, scopeSting)
        )
        return Uri.parse(url)
    }

    /**
     * Returns a {@code Pair} of tokens, where first - access token, second - refresh token
     *
     * @param authCode - temporary code generated by coinbase and available for retrieval
     * from link, generated by method {@see startAuth(redirectUri: String, vararg scopes: String)}
     */
    internal suspend fun completeAuth(url: String): ResponseState<Pair<String, String>> {
        try {
            val authCode = retrieveAuthCode(url)

            val requestAccessToken = RequestAccessToken(
                clientId,
                clientSecret,
                GRANT_TYPE_ACCESS_TOKEN,
                REDIRECT_URI_VALUE,
                authCode
            )
            val responseToken = oAuth2Service.getAccessToken(requestAccessToken)

            return ResponseState.Data(
                Pair("$tokenType${responseToken.accessToken}", responseToken.refreshToken)
            )
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    internal suspend fun refreshToken(refreshToken: String): ResponseState<Pair<String, String>> {
        try {
            val requestRefreshToken = RequestRefreshToken(
                clientId,
                clientSecret,
                GRANT_TYPE_REFRESH_TOKEN,
                refreshToken
            )
            val responseToken = oAuth2Service.refreshToken(requestRefreshToken)

            return ResponseState.Data(
                Pair("$tokenType${responseToken.accessToken}", responseToken.refreshToken)
            )
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    internal suspend fun revokeToken(accessToken: String): ResponseState<Boolean> {
        try {
            val requestRevokeToken = RequestRevokeToken(accessToken.substring(tokenType.length))
            val revokeResponse = oAuth2Service.revokeToken(requestRevokeToken, accessToken)
            return ResponseState.Data(revokeResponse)
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    private fun retrieveAuthCode(url: String): String {
        if (url.contains(BASE_AUTH_URL)) {
            return url.substring(BASE_AUTH_URL.length + 1)
        } else {
            throw IllegalArgumentException("Invalid url in response")
        }
    }
}