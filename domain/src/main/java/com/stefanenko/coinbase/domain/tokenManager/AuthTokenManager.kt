package com.stefanenko.coinbase.domain.tokenManager

import android.net.Uri
import com.stefanenko.coinbase.data.network.dto.token.RequestAccessToken
import com.stefanenko.coinbase.data.network.dto.token.RequestRefreshToken
import com.stefanenko.coinbase.data.network.dto.token.RequestRevokeToken
import com.stefanenko.coinbase.data.service.OAuth2Service
import com.stefanenko.coinbase.domain.entity.ResponseState
import com.stefanenko.coinbase.domain.tokenManager.scope.ScopeBuilder
import com.stefanenko.coinbase.domain.util.UrlBuilder
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.Exception

@Singleton
class AuthTokenManager @Inject constructor(
    private val oAuth2Service: OAuth2Service
) {

    private val clientId = "979fbe1bf76735a1179d82729ed941ffdd5331686891c10c12d1b25f24ac5293"
    private val clientSecret = "208dfff66f3af0ad840541b2dc41f417ce785f187913acb6837bdb39e338e207"
    private val tokenType = "Bearer "

    fun startAuth(redirectUri: String, vararg scopes: String): Uri {
        val scopeSting = ScopeBuilder.build(*scopes)
        val url = UrlBuilder.buildUrl(
            BASE_AUTH_URL,
            Pair(CLIENT_ID_KEY, clientId),
            Pair(REDIRECT_URI_KEY, redirectUri),
            Pair(RESPONSE_TYPE_KEY, RESPONSE_TYPE_VALUE),
            Pair(SCOPE_KEY, scopeSting)
        )
        return Uri.parse(url)
    }

    /**
     * Returns a {@code Pair} of tokens, where first - access token, second - refresh token
     *
     * @param authCode - temporary code generated by coinbase and available for retrieval
     * from link, generated by method {@see startAuth(redirectUri: String, vararg scopes: String)}
     */
    suspend fun completeAuth(authCode: String): ResponseState<Pair<String, String>> {
        try {
            val requestAccessToken = RequestAccessToken(
                clientId,
                clientSecret,
                GRANT_TYPE_ACCESS_TOKEN,
                REDIRECT_URI_VALUE,
                authCode
            )
            val responseToken = oAuth2Service.getAccessToken(requestAccessToken)

            return ResponseState.Data(
                Pair(
                    "$tokenType${responseToken.accessToken}",
                    responseToken.refreshToken
                )
            )
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    suspend fun refreshToken(refreshToken: String): ResponseState<Pair<String, String>> {
        try {
            val requestRefreshToken = RequestRefreshToken(
                clientId,
                clientSecret,
                GRANT_TYPE_REFRESH_TOKEN,
                refreshToken
            )
            val responseToken = oAuth2Service.refreshToken(requestRefreshToken)

            return ResponseState.Data(Pair(responseToken.accessToken, responseToken.refreshToken))
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    suspend fun revokeToken(accessToken: String): ResponseState<Boolean> {
        try {
            val requestRevokeToken = RequestRevokeToken(accessToken.substring(tokenType.length))
            val revokeResponse = oAuth2Service.revokeToken(requestRevokeToken, accessToken)
            return ResponseState.Data(revokeResponse)
        } catch (e: Exception) {
            e.printStackTrace()
            return ResponseState.Error(e.message ?: "ERROR_MESSAGE_MISSING")
        }
    }

    //    fun build(clientId: String, clientSecret: String): TokenManager {
//        if (!this::clientId.isInitialized && !this::clientSecret.isInitialized) {
//            this.clientId = clientId
//            this.clientSecret = clientSecret
//        }
//        return this
//    }

}